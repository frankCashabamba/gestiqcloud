from __future__ import annotations

import hashlib
from datetime import datetime
from typing import Any, Dict, Iterable, List, Optional
import os

from sqlalchemy.orm import Session
import logging
from uuid import UUID, uuid4

from app.modules.imports.application.use_utils import apply_mapping
from app.modules.imports.domain.handlers import BankHandler, ExpenseHandler, InvoiceHandler
from app.modules.imports.infrastructure.repositories import ImportsRepository
from app.modules.imports.validators import validate_bank, validate_expenses, validate_invoices
from app.models.core.modelsimport import ImportBatch, ImportItem, ImportItemCorrection, ImportLineage

# --- helpers -----------------------------------------------------------------

def _to_uuid(v) -> UUID:
    return v if isinstance(v, UUID) else UUID(str(v))

def _idempotency_key(empresa_id: int | str, file_key: Optional[str], idx: int) -> str:
    base = f"{str(empresa_id)}:{file_key or ''}:{idx}"
    return hashlib.sha256(base.encode()).hexdigest()

def _validate_by_type(source_type: str, normalized: Dict[str, Any]) -> List[Dict[str, Any]]:
    # Feature flags simples vÃ­a env
    validate_currency = (os.getenv("IMPORTS_VALIDATE_CURRENCY", "true").lower() in ("1", "true", "yes"))
    # Activado por defecto: puede desactivarse con IMPORTS_REQUIRE_CATEGORIES=false
    require_categories = (os.getenv("IMPORTS_REQUIRE_CATEGORIES", "true").lower() in ("1", "true", "yes"))

    if source_type == "invoices":
        return validate_invoices(normalized, enable_currency_rule=validate_currency)
    if source_type == "bank":
        return validate_bank(normalized)
    if source_type in ("expenses", "receipts"):
        return validate_expenses(normalized, require_categories=require_categories)
    return []

def _dedupe_hash(source_type: str, data: Dict[str, Any]) -> str:
    def g(*keys):
        for k in keys:
            if k in data and data[k] is not None:
                return str(data[k])
        return ""
    if source_type == "invoices":
        parts = [g("issuer_tax_id","issuer","supplier_tax_id"),
                 g("invoice_number","invoice","number"),
                 g("invoice_date","date"),
                 g("total_amount","total")]
    elif source_type == "bank":
        parts = [g("statement_id"),
                 g("entry_ref","reference"),
                 g("transaction_date","date"),
                 g("amount","importe"),
                 g("description","concept","concepto")]
    else:  # expenses/receipts
        parts = [g("expense_date","date"),
                 g("amount","importe"),
                 g("category","categoria"),
                 g("description","concept","concepto")]
    payload = "|".join(parts)
    return hashlib.sha256(payload.encode()).hexdigest()


def _merge_src(raw: Dict[str, Any] | None, normalized: Dict[str, Any] | None) -> Dict[str, Any]:
    """Devuelve raw sobreescrito por normalized cuando exista."""
    raw = raw or {}
    normalized = normalized or {}
    if not normalized:
        return raw
    merged = dict(raw)
    merged.update(normalized)
    return merged

# --- use cases ---------------------------------------------------------------

def create_batch(db: Session, empresa_id: int, user_id: Any, dto: Dict[str, Any]) -> ImportBatch:
    # created_by se guarda como String (UUID en string si es posible)
    try:
        created_by_uuid = user_id if isinstance(user_id, UUID) else _to_uuid(user_id)
        created_by = str(created_by_uuid)
    except Exception:
        created_by = str(uuid4())

    batch = ImportBatch(
        empresa_id=empresa_id,                 # <-- INT (como en tus modelos)
        source_type=dto["source_type"],
        origin=dto.get("origin") or "api",
        file_key=dto.get("file_key"),
        mapping_id=dto.get("mapping_id"),     # esto es UUID o None segÃºn tu modelo
        status="PENDING",
        created_by=created_by,                # columna String
    )
    db.add(batch)
    db.commit()
    db.refresh(batch)
    return batch

def ingest_rows(
    db: Session,
    empresa_id: int,
    batch: ImportBatch,
    rows: Iterable[Dict[str, Any]],
    mappings: Optional[Dict[str, str]] = None,
    transforms: Optional[Dict[str, Any]] = None,
    defaults: Optional[Dict[str, Any]] = None,
):
    t0 = datetime.utcnow()
    repo = ImportsRepository()
    created: List[Dict[str, Any]] = []
    for idx, raw in enumerate(rows):
        normalized = apply_mapping(raw, mappings, transforms, defaults) if mappings else None
        src = _merge_src(raw, normalized)
        errors = _validate_by_type(batch.source_type, src)
        status = "OK" if not errors else "ERROR_VALIDATION"
        dedupe = _dedupe_hash(batch.source_type, src)
        idem = _idempotency_key(empresa_id, batch.file_key, idx)
        created.append({
            "idx": idx,
            "raw": raw,
            "normalized": normalized,
            "status": status,
            "errors": errors,
            "idempotency_key": idem,
            "dedupe_hash": dedupe,
        })
    if created:
        repo.bulk_add_items(db, empresa_id, batch.id, created)  # empresa_id INT
        batch.status = "READY"
        db.add(batch)
        db.commit()
        db.refresh(batch)
    t1 = datetime.utcnow()
    try:
        logging.getLogger("imports").info(
            "ingest_rows",
            extra={
                "tenant": empresa_id,
                "batch_id": str(batch.id),
                "items_total": len(created),
                "t_parse_ms": int((t1 - t0).total_seconds() * 1000),
            },
        )
    except Exception:
        pass
    return repo.list_items(db, empresa_id, batch.id)

def revalidate_batch(db: Session, empresa_id: int, batch_id: UUID | str):
    batch_uuid = _to_uuid(batch_id)
    repo = ImportsRepository()
    batch = repo.get_batch(db, empresa_id, batch_uuid)   # empresa_id INT, batch_id UUID
    if not batch:
        return []
    items = repo.list_items(db, empresa_id, batch_uuid)
    for it in items:
        src = _merge_src(it.raw, it.normalized)
        errors = _validate_by_type(batch.source_type, src)
        it.errors = errors
        it.status = "OK" if not errors else "ERROR_VALIDATION"
        db.add(it)
    db.commit()
    out = repo.list_items(db, empresa_id, batch_uuid)
    try:
        logging.getLogger("imports").info(
            "revalidate_batch",
            extra={
                "tenant": empresa_id,
                "batch_id": str(batch_uuid),
                "items_total": len(out),
                "items_ok": sum(1 for x in out if x.status == "OK"),
                "items_error": sum(1 for x in out if x.status and x.status.startswith("ERROR")),
            },
        )
    except Exception:
        pass
    return out

def patch_item(db: Session, empresa_id: int, user_id: Any, batch_id, item_id, field: str, value: Any):
    batch_uuid = _to_uuid(batch_id)
    item_uuid  = _to_uuid(item_id)

    repo = ImportsRepository()
    batch = repo.get_batch(db, empresa_id, batch_uuid)
    if not batch:
        return None

    from sqlalchemy import and_
    it = (
        db.query(ImportItem)
        .join(ImportBatch, ImportItem.batch_id == ImportBatch.id)
        .filter(and_(ImportItem.id == item_uuid, ImportBatch.empresa_id == empresa_id))
        .first()
    )
    if not it:
        return None

    # ðŸ‘‡ CLAVE: partir de todos los campos disponibles
    base = it.normalized or it.raw or {}
    normalized = dict(base)
    old_value = normalized.get(field)
    normalized[field] = value
    it.normalized = normalized

    # revalidar con el payload completo ya actualizado
    src = _merge_src(it.raw, it.normalized)
    errors = _validate_by_type(batch.source_type, src)
    it.errors = errors
    it.status = "OK" if not errors else "ERROR_VALIDATION"
    db.add(it)

    # correcciÃ³n (user_id â†’ UUID si puedes; si no, genera uno)
    try:
        uid = user_id if isinstance(user_id, UUID) else _to_uuid(user_id)
    except Exception:
        uid = uuid4()

    corr = ImportItemCorrection(
        empresa_id=empresa_id,
        item_id=item_uuid,
        user_id=uid,
        field=field,
        old_value=old_value,
        new_value=value,
    )
    db.add(corr)
    db.commit()
    db.refresh(it)
    return it

def promote_batch(db: Session, empresa_id: int, batch_id):
    batch_uuid = _to_uuid(batch_id)

    repo = ImportsRepository()
    batch = repo.get_batch(db, empresa_id, batch_uuid)
    if not batch:
        return {"created": 0, "skipped": 0, "failed": 0}

    # Consider all items; we'll count already promoted as skipped to make idempotency visible
    items = repo.list_items(db, empresa_id, batch_uuid)
    created = skipped = failed = 0
    handler = {
        "invoices": InvoiceHandler,
        "bank": BankHandler,
        "receipts": ExpenseHandler,
        "expenses": ExpenseHandler,
    }.get(batch.source_type, ExpenseHandler)

    t0 = datetime.utcnow()
    for it in items:
        # Already promoted: count as skipped (idempotent)
        if it.status == "PROMOTED":
            skipped += 1
            continue
        # Only attempt to promote valid items
        if it.status != "OK":
            continue
        try:
            if it.dedupe_hash and repo.exists_promoted_hash(db, empresa_id, it.dedupe_hash):
                skipped += 1
                continue
            res = handler.promote(it.normalized or it.raw or {}, it.promoted_id)
            if res.skipped:
                skipped += 1
                continue
            it.promoted_to = batch.source_type
            it.promoted_id = None
            it.promoted_at = datetime.utcnow()
            it.status = "PROMOTED"
            db.add(it)

            lineage = ImportLineage(
                empresa_id=empresa_id,   # INT
                item_id=it.id,           # UUID
                promoted_to=batch.source_type,
                promoted_ref=res.domain_id or "",
            )
            db.add(lineage)
            created += 1
        except Exception:
            it.status = "ERROR_PROMOTION"
            db.add(it)
            failed += 1
    db.commit()
    t1 = datetime.utcnow()
    try:
        logging.getLogger("imports").info(
            "promote_batch",
            extra={
                "tenant": empresa_id,
                "batch_id": str(batch_uuid),
                "items_total": len(items),
                "items_ok": created,
                "items_error": failed,
                "t_promote_ms": int((t1 - t0).total_seconds() * 1000),
            },
        )
    except Exception:
        pass
    return {"created": created, "skipped": skipped, "failed": failed}
