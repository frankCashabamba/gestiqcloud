from __future__ import annotations

from datetime import datetime
from decimal import ROUND_HALF_UP, Decimal
from typing import List, Optional
from uuid import UUID

from app.config.database import get_db
from app.core.access_guard import with_access_claims
from app.core.authz import require_scope
from app.db.rls import ensure_guc_from_request, ensure_rls
from fastapi import APIRouter, Depends, HTTPException, Request, Query
from fastapi.responses import HTMLResponse
from psycopg2.extras import Json
from pydantic import BaseModel, Field, field_validator
from sqlalchemy import text
from sqlalchemy.orm import Session

router = APIRouter(
    prefix="/pos",
    tags=["POS"],
    dependencies=[
        Depends(with_access_claims),
        Depends(require_scope("tenant")),
        Depends(ensure_rls),
    ],
)


# ============================================================================
# UTILIDADES
# ============================================================================


def _get_tenant_id(request: Request) -> UUID:
    """Obtiene tenant_id como UUID (evita casts en SQL)."""
    claims = getattr(request.state, "access_claims", {}) or {}
    if not isinstance(claims, dict):
        raise HTTPException(status_code=401, detail="Claims inválidos")

    tenant_id = claims.get("tenant_id")
    if not tenant_id:
        raise HTTPException(status_code=401, detail="Tenant ID no encontrado")

    try:
        return UUID(str(tenant_id))
    except Exception:
        raise HTTPException(status_code=401, detail="Tenant ID inválido")


def _get_user_id(request: Request) -> UUID:
    """Obtiene user_id como UUID desde los claims (sin casts en SQL)."""
    claims = getattr(request.state, "access_claims", {}) or {}
    if not isinstance(claims, dict):
        raise HTTPException(status_code=401, detail="Claims inválidos")

    user_id = claims.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Usuario no autenticado")

    try:
        return UUID(str(user_id))
    except Exception:
        raise HTTPException(status_code=401, detail="User ID inválido")


def _validate_uuid(value: str, field_name: str = "ID") -> UUID:
    """Valida y convierte un string a UUID"""
    try:
        return UUID(value)
    except (ValueError, AttributeError, TypeError):
        raise HTTPException(
            status_code=400, detail=f"{field_name} inválido: debe ser un UUID válido"
        )


def _to_decimal(value: float) -> Decimal:
    """Convierte float a Decimal con 2 decimales"""
    return Decimal(str(value)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)


# ============================================================================
# MODELOS PYDANTIC
# ============================================================================


class RegisterIn(BaseModel):
    code: str = Field(min_length=1, max_length=50)
    name: str = Field(min_length=1, max_length=200)
    default_warehouse_id: Optional[str] = None
    metadata: Optional[dict] = None

    @field_validator("default_warehouse_id")
    @classmethod
    def validate_warehouse_id(cls, v):
        if v is not None:
            _validate_uuid(v, "Warehouse ID")
        return v


class OpenShiftIn(BaseModel):
    register_id: str
    opening_float: float = Field(ge=0, description="Monto inicial debe ser >= 0")

    @field_validator("register_id")
    @classmethod
    def validate_register_id(cls, v):
        _validate_uuid(v, "Register ID")
        return v


class ReceiptLineIn(BaseModel):
    product_id: str
    qty: float = Field(gt=0, description="Cantidad debe ser > 0")
    unit_price: float = Field(ge=0)
    tax_rate: float = Field(ge=0, le=1, default=0)
    discount_pct: float = Field(ge=0, le=100, default=0)
    uom: str = Field(default="unit", max_length=20)

    @field_validator("product_id")
    @classmethod
    def validate_product_id(cls, v):
        _validate_uuid(v, "Product ID")
        return v

    @property
    def line_total(self) -> float:
        """Calcula el total de la línea"""
        subtotal = self.qty * self.unit_price
        discount = subtotal * (self.discount_pct / 100)
        return subtotal - discount


class PaymentIn(BaseModel):
    method: str = Field(min_length=1, max_length=50)
    amount: float = Field(gt=0, description="Monto debe ser > 0")
    ref: Optional[str] = Field(default=None, max_length=200)


class ReceiptCreateIn(BaseModel):
    shift_id: str
    register_id: str
    lines: List[ReceiptLineIn] = Field(default_factory=list)
    payments: List[PaymentIn] = Field(default_factory=list)
    notes: Optional[str] = Field(default=None, max_length=500)

    @field_validator("shift_id", "register_id")
    @classmethod
    def validate_ids(cls, v):
        _validate_uuid(v, "ID")
        return v


class CheckoutIn(BaseModel):
    payments: List[PaymentIn] = Field(min_length=1)
    warehouse_id: Optional[str] = None

    @field_validator("warehouse_id")
    @classmethod
    def validate_warehouse_id(cls, v):
        if v is not None:
            _validate_uuid(v, "Warehouse ID")
        return v


class CloseShiftIn(BaseModel):
    closing_cash: float = Field(ge=0)


class ItemIn(BaseModel):
    product_id: int
    qty: float = Field(gt=0)
    unit_price: float = Field(ge=0)
    tax: Optional[float] = Field(default=None, ge=0)


class RemoveItemIn(BaseModel):
    item_id: int


class PaymentsIn(BaseModel):
    payments: List[PaymentIn]


class PostReceiptIn(BaseModel):
    warehouse_id: Optional[int] = None


# ============================================================================
# ENDPOINTS - REGISTERS
# ============================================================================


@router.get("/registers", response_model=List[dict])
def list_registers(request: Request, db: Session = Depends(get_db)):
    """Lista todos los registros POS del tenant actual"""
    ensure_guc_from_request(request, db, persist=True)

    try:
        rows = db.execute(
            text(
                "SELECT id, name, store_id, active, created_at "
                "FROM pos_registers "
                "ORDER BY created_at DESC"
            )
        ).fetchall()

        return [
            {
                "id": str(r[0]),
                "name": r[1],
                "store_id": str(r[2]) if r[2] else None,
                "active": r[3],
                "created_at": r[4].isoformat() if r[4] else None,
            }
            for r in rows
        ]
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error al listar registros: {str(e)}"
        )


@router.post("/registers", response_model=dict, status_code=201)
def create_register(
    payload: RegisterIn, request: Request, db: Session = Depends(get_db)
):
    """Crea un nuevo registro POS"""
    ensure_guc_from_request(request, db, persist=True)
    tid = _get_tenant_id(request)

    try:
        # Verificar código único
        existing = db.execute(
            text("SELECT id FROM pos_registers WHERE code = :code AND tenant_id = :tid::uuid"),
            {"code": payload.code, "tid": str(tid)},
        ).first()

        if existing:
            raise HTTPException(
                status_code=400,
                detail=f"Ya existe un registro con el código '{payload.code}'",
            )

        row = db.execute(
            text(
                "INSERT INTO pos_registers(tenant_id, code, name, default_warehouse_id, metadata) "
                "VALUES (:tid::uuid, :code, :name, :wh::uuid, :md) RETURNING id"
            ),
            {
                "tid": str(tid),
                "code": payload.code,
                "name": payload.name,
                "wh": (
                    UUID(payload.default_warehouse_id)
                    if payload.default_warehouse_id
                    else None
                ),
                "md": Json(payload.metadata) if payload.metadata else None,
            },
        ).first()

        db.commit()
        return {"id": str(row[0])}

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500, detail=f"Error al crear registro: {str(e)}"
        )


# ============================================================================
# ENDPOINTS - SHIFTS
# ============================================================================


@router.post("/shifts", response_model=dict)
@router.post("/open_shift", response_model=dict, deprecated=True)
def open_shift(payload: OpenShiftIn, request: Request, db: Session = Depends(get_db)):
    """Abre un nuevo turno en un registro POS"""
    ensure_guc_from_request(request, db, persist=True)

    user_id = _get_user_id(request)
    register_uuid = _validate_uuid(payload.register_id, "Register ID")

    try:
        # Verificar que el registro existe y está activo
        register = db.execute(
            text("SELECT active FROM pos_registers WHERE id = :rid"),
            {"rid": register_uuid},
        ).first()

        if not register:
            raise HTTPException(status_code=404, detail="Registro no encontrado")

        if not register[0]:
            raise HTTPException(status_code=400, detail="El registro está inactivo")

        # Verificar que no hay un turno abierto
        existing = db.execute(
            text(
                "SELECT id FROM pos_shifts "
                "WHERE register_id = :rid AND status = 'open' "
                "FOR UPDATE"
            ),
            {"rid": register_uuid},
        ).first()

        if existing:
            raise HTTPException(
                status_code=400, detail="Ya existe un turno abierto para este registro"
            )

        # Insertar turno
        row = db.execute(
            text(
                "INSERT INTO pos_shifts(register_id, opened_by, opening_float, status) "
                "VALUES (:rid, :opened_by, :opening_float, 'open') "
                "RETURNING id"
            ),
            {
                "rid": register_uuid,
                "opened_by": user_id,
                "opening_float": payload.opening_float,
            },
        ).first()

        db.commit()
        return {"id": str(row[0]), "status": "open"}

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al abrir turno: {str(e)}")


@router.post("/shifts/{shift_id}/close", response_model=dict)
def close_shift(
    shift_id: str,
    payload: CloseShiftIn,
    request: Request,
    db: Session = Depends(get_db),
):
    """Cierra un turno POS"""
    ensure_guc_from_request(request, db, persist=True)
    shift_uuid = _validate_uuid(shift_id, "Shift ID")

    try:
        # Verificar que el turno existe y está abierto
        shift = db.execute(
            text("SELECT status FROM pos_shifts WHERE id = :sid FOR UPDATE"),
            {"sid": str(shift_uuid)},
        ).first()

        if not shift:
            raise HTTPException(status_code=404, detail="Turno no encontrado")

        if shift[0] != "open":
            raise HTTPException(status_code=400, detail="El turno ya está cerrado")

        # Calcular efectivo esperado
        cash_row = db.execute(
            text(
                "SELECT COALESCE(SUM(pp.amount), 0) "
                "FROM pos_payments pp "
                "JOIN pos_receipts pr ON pr.id = pp.receipt_id "
                "WHERE pr.shift_id = :sid AND pp.method = 'cash'"
            ),
            {"sid": str(shift_uuid)},
        ).first()

        expected_cash = float(cash_row[0] or 0)

        # Cerrar turno
        db.execute(
            text(
                "UPDATE pos_shifts "
                "SET status = 'closed', closed_at = NOW(), closing_cash = :cc "
                "WHERE id = :sid"
            ),
            {"sid": str(shift_uuid), "cc": payload.closing_cash},
        )

        db.commit()

        diff = payload.closing_cash - expected_cash

        return {
            "status": "closed",
            "expected_cash": expected_cash,
            "counted_cash": payload.closing_cash,
            "difference": diff,
        }

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al cerrar turno: {str(e)}")


@router.get("/shifts", response_model=List[dict])
def list_shifts(
    request: Request,
    status: Optional[str] = None,
    since: Optional[str] = None,
    until: Optional[str] = None,
    limit: int = Query(default=200, le=1000),
    db: Session = Depends(get_db),
):
    """Lista turnos POS con filtros opcionales"""
    ensure_guc_from_request(request, db, persist=True)

    sql_parts = [
        "SELECT id, register_id, opened_at, closed_at, opening_float, closing_cash, status, opened_by "
        "FROM pos_shifts WHERE 1=1"
    ]
    params = {}

    if status:
        sql_parts.append("AND status = :st")
        params["st"] = status

    if since:
        sql_parts.append("AND opened_at >= :since")
        params["since"] = since

    if until:
        sql_parts.append("AND opened_at <= :until")
        params["until"] = until

    sql_parts.append(f"ORDER BY opened_at DESC LIMIT {min(limit, 1000)}")

    try:
        rows = db.execute(text(" ".join(sql_parts)), params).fetchall()

        return [
            {
                "id": str(r[0]),
                "register_id": str(r[1]),
                "opened_at": r[2].isoformat() if r[2] else None,
                "closed_at": r[3].isoformat() if r[3] else None,
                "opening_float": float(r[4]) if r[4] else 0,
                "closing_cash": float(r[5]) if r[5] else None,
                "status": r[6],
                "opened_by": str(r[7]),
            }
            for r in rows
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error al listar turnos: {str(e)}")


@router.get("/shifts/{shift_id}/summary", response_model=dict)
def shift_summary(shift_id: str, request: Request, db: Session = Depends(get_db)):
    """Resumen de un turno POS"""
    ensure_guc_from_request(request, db, persist=True)
    shift_uuid = _validate_uuid(shift_id, "Shift ID")

    try:
        # Totales por método de pago
        payments = db.execute(
            text(
                "SELECT pp.method, COALESCE(SUM(pp.amount), 0) AS amount "
                "FROM pos_payments pp "
                "JOIN pos_receipts pr ON pr.id = pp.receipt_id "
                "WHERE pr.shift_id = :sid "
                "GROUP BY pp.method "
                "ORDER BY amount DESC"
            ),
            {"sid": str(shift_uuid)},
        ).fetchall()

        # Conteo de recibos
        receipts = db.execute(
            text(
                "SELECT "
                "COUNT(*) FILTER (WHERE status = 'paid') AS paid, "
                "COUNT(*) FILTER (WHERE status = 'draft') AS draft "
                "FROM pos_receipts WHERE shift_id = :sid"
            ),
            {"sid": str(shift_uuid)},
        ).first()

        # Totales
        totals = db.execute(
            text(
                "SELECT "
                "COALESCE(SUM(gross_total), 0) AS gross, "
                "COALESCE(SUM(tax_total), 0) AS tax "
                "FROM pos_receipts "
                "WHERE shift_id = :sid AND status = 'paid'"
            ),
            {"sid": str(shift_uuid)},
        ).first()

        return {
            "shift_id": shift_id,
            "receipts": {"paid": int(receipts[0] or 0), "draft": int(receipts[1] or 0)},
            "payments": [{"method": p[0], "amount": float(p[1])} for p in payments],
            "totals": {
                "gross": float(totals[0] or 0),
                "tax": float(totals[1] or 0),
                "total": float((totals[0] or 0) + (totals[1] or 0)),
            },
        }

    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error al obtener resumen: {str(e)}"
        )


# ============================================================================
# ENDPOINTS - RECEIPTS
# ============================================================================


@router.post("/receipts", response_model=dict, status_code=201)
def create_receipt(
    payload: ReceiptCreateIn, request: Request, db: Session = Depends(get_db)
):
    """Crea un nuevo recibo POS"""
    ensure_guc_from_request(request, db, persist=True)

    tenant_id = _get_tenant_id(request)
    shift_uuid = _validate_uuid(payload.shift_id, "Shift ID")
    register_uuid = _validate_uuid(payload.register_id, "Register ID")

    try:
        # Verificar que el turno existe y está abierto
        shift = db.execute(
            text(
                "SELECT status FROM pos_shifts WHERE id = :sid AND register_id = :rid"
            ),
            {"sid": shift_uuid, "rid": register_uuid},
        ).first()

        if not shift:
            raise HTTPException(status_code=404, detail="Turno no encontrado")

        if shift[0] != "open":
            raise HTTPException(status_code=400, detail="El turno no está abierto")

        # Generar número de ticket usando secuencia atómica
        ticket_number = db.execute(
            text(
                "SELECT COALESCE(MAX(CAST(SPLIT_PART(number, '-', 2) AS INTEGER)), 0) + 1 "
                "FROM pos_receipts "
                "WHERE tenant_id = :tid AND register_id = :rid"
            ),
            {"tid": tenant_id, "rid": register_uuid},
        ).scalar()

        ticket_number = f"R-{ticket_number:04d}"

        # Crear el recibo
        row = db.execute(
            text(
                "INSERT INTO pos_receipts("
                "tenant_id, register_id, shift_id, number, status, "
                "gross_total, tax_total, currency"
                ") VALUES ("
                ":tid, :rid, :sid, :number, 'draft', "
                "0, 0, 'EUR'"
                ") RETURNING id"
            ),
            {
                "tid": tenant_id,
                "rid": register_uuid,
                "sid": shift_uuid,
                "number": ticket_number,
            },
        ).first()

        receipt_id = row[0]

        # Insertar líneas
        for line in payload.lines:
            product_uuid = _validate_uuid(line.product_id, "Product ID")

            db.execute(
                text(
                    "INSERT INTO pos_receipt_lines("
                    "receipt_id, product_id, qty, unit_price, tax_rate, "
                    "discount_pct, line_total, uom"
                    ") VALUES ("
                    ":receipt_id, :product_id, :qty, :unit_price, :tax_rate, "
                    ":discount_pct, :line_total, :uom"
                    ")"
                ),
                {
                    "receipt_id": receipt_id,
                    "product_id": product_uuid,
                    "qty": line.qty,
                    "unit_price": line.unit_price,
                    "tax_rate": line.tax_rate,
                    "discount_pct": line.discount_pct,
                    "line_total": line.line_total,
                    "uom": line.uom,
                },
            )

        db.commit()
        return {"id": str(receipt_id), "number": ticket_number}

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al crear recibo: {str(e)}")


@router.post("/receipts/{receipt_id}/checkout", response_model=dict)
def checkout(
    receipt_id: str,
    payload: CheckoutIn,
    request: Request,
    db: Session = Depends(get_db),
):
    """Registra pagos y descuenta stock en una transacción atómica"""
    ensure_guc_from_request(request, db, persist=True)
    receipt_uuid = _validate_uuid(receipt_id, "Receipt ID")

    try:
        # 1. Validar estado del recibo
        receipt = db.execute(
            text("SELECT shift_id, status FROM pos_receipts WHERE id = :id FOR UPDATE"),
            {"id": receipt_uuid},
        ).first()

        if not receipt:
            raise HTTPException(status_code=404, detail="Recibo no encontrado")

        if receipt[1] != "draft":
            raise HTTPException(
                status_code=400,
                detail=f"Recibo en estado '{receipt[1]}', debe estar en 'draft'",
            )

        # 2. Insertar pagos
        for payment in payload.payments:
            db.execute(
                text(
                    "INSERT INTO pos_payments(receipt_id, method, amount, ref) "
                    "VALUES (:rid, :m, :a, :ref)"
                ),
                {
                    "rid": receipt_uuid,
                    "m": payment.method,
                    "a": payment.amount,
                    "ref": payment.ref,
                },
            )

        # 3. Calcular totales
        totals = db.execute(
            text(
                "SELECT "
                "COALESCE(SUM(rl.qty * rl.unit_price * (1 - rl.discount_pct/100)), 0) AS subtotal, "
                "COALESCE(SUM(rl.qty * rl.unit_price * (1 - rl.discount_pct/100) * rl.tax_rate), 0) AS tax "
                "FROM pos_receipt_lines rl "
                "WHERE rl.receipt_id = :rid"
            ),
            {"rid": receipt_uuid},
        ).first()

        payments_total = db.execute(
            text(
                "SELECT COALESCE(SUM(amount), 0) "
                "FROM pos_payments "
                "WHERE receipt_id = :rid"
            ),
            {"rid": receipt_uuid},
        ).first()

        # Convertir a Decimal para precisión
        subtotal = _to_decimal(float(totals[0] or 0))
        tax = _to_decimal(float(totals[1] or 0))
        total = subtotal + tax
        paid = _to_decimal(float(payments_total[0] or 0))

        # Validar pago suficiente (comparar en centavos)
        if int(paid * 100) < int(total * 100):
            raise HTTPException(
                status_code=400,
                detail=f"Pago insuficiente. Recibido: ${paid:.2f}, Requerido: ${total:.2f}",
            )

        # 4. Determinar almacén
        warehouse_id = payload.warehouse_id

        if warehouse_id:
            warehouse_uuid = _validate_uuid(warehouse_id, "Warehouse ID")
        else:
            # Buscar almacén único activo
            warehouses = db.execute(
                text("SELECT id FROM warehouses WHERE active = true LIMIT 2")
            ).fetchall()

            if len(warehouses) == 0:
                raise HTTPException(
                    status_code=400, detail="No hay almacenes activos disponibles"
                )
            elif len(warehouses) > 1:
                raise HTTPException(
                    status_code=400,
                    detail="Múltiples almacenes disponibles, debe especificar warehouse_id",
                )

            warehouse_uuid = warehouses[0][0]

        # 5. Procesar stock por cada línea
        lines = db.execute(
            text(
                "SELECT product_id, qty FROM pos_receipt_lines WHERE receipt_id = :rid"
            ),
            {"rid": receipt_uuid},
        ).fetchall()

        for line in lines:
            product_id = line[0]
            qty_sold = float(line[1])

            # Registrar movimiento de stock
            db.execute(
                text(
                    "INSERT INTO stock_moves("
                    "tenant_id, product_id, warehouse_id, qty, kind, ref_type, ref_id"
                    ") VALUES ("
                    ":tid, :pid, :wid, :q, 'sale', 'pos_receipt', :rid"
                    ")"
                ),
                {
                    "tid": _get_tenant_id(request),
                    "pid": product_id,
                    "wid": warehouse_uuid,
                    "q": qty_sold,
                    "rid": receipt_uuid,
                },
            )

            # Actualizar stock_items con lock
            stock_item = db.execute(
                text(
                    "SELECT id, qty_on_hand FROM stock_items "
                    "WHERE warehouse_id = :wid AND product_id = :pid "
                    "FOR UPDATE"
                ),
                {"wid": warehouse_uuid, "pid": product_id},
            ).first()

            if stock_item is None:
                # Crear registro con stock 0
                db.execute(
                    text(
                        "INSERT INTO stock_items("
                        "id, tenant_id, warehouse_id, product_id, qty_on_hand"
                        ") VALUES ("
                        "gen_random_uuid(), :tid, :wid, :pid, 0"
                        ")"
                    ),
                    {
                        "tid": _get_tenant_id(request),
                        "wid": warehouse_uuid,
                        "pid": product_id,
                    },
                )
                current_qty = 0.0
            else:
                current_qty = float(stock_item[1] or 0)

            new_qty = current_qty - qty_sold

            # Advertir si stock queda negativo (pero no bloquear)
            if new_qty < 0:
                # Podrías loggear esto o enviar una notificación
                pass

            db.execute(
                text(
                    "UPDATE stock_items SET qty_on_hand = :q "
                    "WHERE warehouse_id = :wid AND product_id = :pid"
                ),
                {"q": new_qty, "wid": warehouse_uuid, "pid": product_id},
            )

        # 6. Marcar recibo como pagado
        db.execute(
            text(
                "UPDATE pos_receipts "
                "SET status = 'paid', gross_total = :gt, tax_total = :tt, paid_at = NOW() "
                "WHERE id = :id"
            ),
            {"id": receipt_uuid, "gt": total, "tt": tax},
        )

        db.commit()

        return {
            "ok": True,
            "receipt_id": str(receipt_uuid),
            "status": "paid",
            "totals": {
                "subtotal": float(subtotal),
                "tax": float(tax),
                "total": float(total),
                "paid": float(paid),
                "change": float(paid - total),
            },
        }

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error en checkout: {str(e)}")


@router.get("/receipts", response_model=List[dict])
def list_receipts(
    request: Request,
    status: Optional[str] = None,
    since: Optional[str] = None,
    until: Optional[str] = None,
    shift_id: Optional[str] = None,
    limit: int = Query(default=500, le=1000),
    db: Session = Depends(get_db),
):
    """Lista recibos con filtros opcionales"""
    ensure_guc_from_request(request, db, persist=True)

    sql_parts = [
        "SELECT id, shift_id, register_id, number, status, gross_total, tax_total, "
        "created_at, paid_at "
        "FROM pos_receipts WHERE 1=1"
    ]
    params = {}

    if status:
        sql_parts.append("AND status = :st")
        params["st"] = status

    if shift_id:
        shift_uuid = _validate_uuid(shift_id, "Shift ID")
        sql_parts.append("AND shift_id = :sid")
        params["sid"] = shift_uuid

    if since:
        sql_parts.append("AND created_at >= :since")
        params["since"] = since

    if until:
        sql_parts.append("AND created_at <= :until")
        params["until"] = until

    sql_parts.append(f"ORDER BY created_at DESC LIMIT {min(limit, 1000)}")

    try:
        rows = db.execute(text(" ".join(sql_parts)), params).fetchall()

        return [
            {
                "id": str(r[0]),
                "shift_id": str(r[1]),
                "register_id": str(r[2]),
                "number": r[3],
                "status": r[4],
                "gross_total": float(r[5]) if r[5] else 0,
                "tax_total": float(r[6]) if r[6] else 0,
                "created_at": r[7].isoformat() if r[7] else None,
                "paid_at": r[8].isoformat() if r[8] else None,
            }
            for r in rows
        ]
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error al listar recibos: {str(e)}"
        )


@router.get("/receipts/{receipt_id}/print")
def print_receipt(
    receipt_id: str,
    request: Request,
    width: str = "58mm",
    db: Session = Depends(get_db),
):
    """Genera HTML para impresión térmica del ticket"""
    ensure_guc_from_request(request, db, persist=True)
    receipt_uuid = _validate_uuid(receipt_id, "Receipt ID")

    try:
        # Obtener datos del recibo
        receipt = db.execute(
            text(
                "SELECT r.id, r.number, r.gross_total, r.tax_total, r.created_at, r.status "
                "FROM pos_receipts r WHERE r.id = :id"
            ),
            {"id": receipt_uuid},
        ).fetchone()

        if not receipt:
            raise HTTPException(status_code=404, detail="Recibo no encontrado")

        # Obtener líneas
        lines = db.execute(
            text(
                "SELECT rl.qty, rl.unit_price, rl.line_total, p.name "
                "FROM pos_receipt_lines rl "
                "LEFT JOIN products p ON rl.product_id = p.id "
                "WHERE rl.receipt_id = :rid "
                "ORDER BY rl.id"
            ),
            {"rid": receipt_uuid},
        ).fetchall()

        # Obtener pagos
        payments = db.execute(
            text(
                "SELECT method, amount FROM pos_payments "
                "WHERE receipt_id = :rid "
                "ORDER BY paid_at"
            ),
            {"rid": receipt_uuid},
        ).fetchall()

        # Generar HTML
        lines_html = "".join(
            [
                f'<div class="line">'
                f"<span>{line[0]:.2f}x {line[3] or 'Producto'}</span>"
                f"<span>${line[2]:.2f}</span>"
                f"</div>"
                for line in lines
            ]
        )

        payments_html = "".join(
            [
                f'<div class="line"><span>{p[0].upper()}</span><span>${p[1]:.2f}</span></div>'
                for p in payments
            ]
        )

        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ticket {receipt[1]}</title>
    <style>
        @page {{ 
            width: {width}; 
            margin: 0; 
        }}
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        body {{ 
            width: 100%;
            max-width: 48mm;
            font-family: 'Courier New', Courier, monospace; 
            font-size: 9pt; 
            margin: 5mm auto;
            padding: 0 2mm;
        }}
        .center {{ 
            text-align: center; 
            margin: 3px 0;
        }}
        .bold {{
            font-weight: bold;
        }}
        .line {{ 
            display: flex; 
            justify-content: space-between; 
            margin: 2px 0;
            font-size: 8pt;
        }}
        .line span:first-child {{
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-right: 5px;
        }}
        .line span:last-child {{
            text-align: right;
            white-space: nowrap;
        }}
        hr {{ 
            border: none; 
            border-top: 1px dashed #000; 
            margin: 5px 0; 
        }}
        .total {{ 
            margin-top: 5px; 
            padding-top: 5px;
            font-weight: bold; 
            font-size: 10pt;
        }}
        .section {{
            margin: 8px 0;
        }}
        .section-title {{
            font-weight: bold;
            margin-bottom: 3px;
            font-size: 8pt;
        }}
        @media print {{
            body {{
                margin: 0;
                padding: 2mm;
            }}
        }}
    </style>
</head>
<body>
    <div class="center bold" style="font-size: 11pt;">TICKET DE VENTA</div>
    <div class="center">Nº {receipt[1] or "N/A"}</div>
    <div class="center" style="font-size: 8pt;">
        {receipt[4].strftime("%d/%m/%Y %H:%M") if receipt[4] else ""}
    </div>
    
    <hr>
    
    <div class="section">
        <div class="section-title">PRODUCTOS</div>
        {lines_html}
    </div>
    
    <hr>
    
    <div class="line">
        <span>SUBTOTAL</span>
        <span>${(receipt[2] - receipt[3]):.2f}</span>
    </div>
    <div class="line">
        <span>IVA</span>
        <span>${receipt[3]:.2f}</span>
    </div>
    <div class="total line">
        <span>TOTAL</span>
        <span>${receipt[2]:.2f}</span>
    </div>
    
    {
            f'''
    <hr>
    <div class="section">
        <div class="section-title">PAGOS</div>
        {payments_html}
    </div>
    '''
            if payments
            else ""
        }
    
    <hr>
    
    <div class="center" style="margin-top: 10px; font-size: 8pt;">
        ¡Gracias por su compra!
    </div>
    
    <div class="center" style="margin-top: 8px; font-size: 7pt;">
        Estado: {receipt[5].upper()}
    </div>
    
    <script>
        // Auto-imprimir al cargar
        window.onload = function() {{
            setTimeout(function() {{
                window.print();
            }}, 500);
        }};
    </script>
</body>
</html>"""

        return HTMLResponse(content=html)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error al generar ticket: {str(e)}"
        )


# ============================================================================
# ENDPOINTS DEPRECATED (Mantener para retrocompatibilidad)
# ============================================================================


@router.post(
    "/receipts/{receipt_id}/add_item",
    response_model=dict,
    deprecated=True,
    include_in_schema=False,
)
def add_item(
    receipt_id: str, payload: ItemIn, request: Request, db: Session = Depends(get_db)
):
    """
    DEPRECATED: Usa POST /receipts con líneas incluidas.
    Agrega un item a un recibo en borrador.
    """
    ensure_guc_from_request(request, db, persist=True)
    receipt_uuid = _validate_uuid(receipt_id, "Receipt ID")

    try:
        rec = db.execute(
            text("SELECT status FROM pos_receipts WHERE id = :id::uuid"),
            {"id": str(receipt_uuid)},
        ).first()

        if not rec or rec[0] != "draft":
            raise HTTPException(status_code=400, detail="El recibo no está en borrador")

        row = db.execute(
            text(
                "INSERT INTO pos_items(receipt_id, product_id, qty, unit_price, tax) "
                "VALUES (:rid::uuid, :pid, :q, :p, :t) RETURNING id"
            ),
            {
                "rid": str(receipt_uuid),
                "pid": payload.product_id,
                "q": payload.qty,
                "p": payload.unit_price,
                "t": payload.tax,
            },
        ).first()

        db.commit()
        return {"id": int(row[0])}

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al agregar item: {str(e)}")


@router.post(
    "/receipts/{receipt_id}/remove_item",
    response_model=dict,
    deprecated=True,
    include_in_schema=False,
)
def remove_item(
    receipt_id: str,
    payload: RemoveItemIn,
    request: Request,
    db: Session = Depends(get_db),
):
    """
    DEPRECATED: Usa PUT /receipts/{id} para modificar líneas.
    Elimina un item de un recibo en borrador.
    """
    ensure_guc_from_request(request, db, persist=True)
    receipt_uuid = _validate_uuid(receipt_id, "Receipt ID")

    try:
        rec = db.execute(
            text("SELECT status FROM pos_receipts WHERE id = :id::uuid"),
            {"id": str(receipt_uuid)},
        ).first()

        if not rec or rec[0] != "draft":
            raise HTTPException(status_code=400, detail="El recibo no está en borrador")

        db.execute(
            text("DELETE FROM pos_items WHERE id = :id AND receipt_id = :rid::uuid"),
            {"id": payload.item_id, "rid": str(receipt_uuid)},
        )

        db.commit()
        return {"ok": True}

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al eliminar item: {str(e)}")


@router.post(
    "/receipts/{receipt_id}/take_payment",
    response_model=dict,
    deprecated=True,
    include_in_schema=False,
)
def take_payment(
    receipt_id: str,
    payload: PaymentsIn,
    request: Request,
    db: Session = Depends(get_db),
):
    """
    DEPRECATED: Usa POST /receipts/{id}/checkout en su lugar.
    Registra pagos en un recibo.
    """
    ensure_guc_from_request(request, db, persist=True)
    receipt_uuid = _validate_uuid(receipt_id, "Receipt ID")

    try:
        rec = db.execute(
            text("SELECT status FROM pos_receipts WHERE id = :id::uuid"),
            {"id": str(receipt_uuid)},
        ).first()

        if not rec or rec[0] != "draft":
            raise HTTPException(status_code=400, detail="El recibo no está en borrador")

        # Insertar pagos
        for payment in payload.payments:
            db.execute(
                text(
                    "INSERT INTO pos_payments(receipt_id, method, amount, ref) "
                    "VALUES (:rid::uuid, :m, :a, :ref)"
                ),
                {
                    "rid": str(receipt_uuid),
                    "m": payment.method,
                    "a": payment.amount,
                    "ref": payment.ref,
                },
            )

        # Marcar como pagado (sin validación de monto)
        db.execute(
            text(
                "UPDATE pos_receipts SET status = 'paid', paid_at = NOW() "
                "WHERE id = :id::uuid"
            ),
            {"id": str(receipt_uuid)},
        )

        db.commit()
        return {"ok": True, "receipt_id": str(receipt_uuid)}

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al procesar pago: {str(e)}")


@router.post(
    "/receipts/{receipt_id}/post",
    response_model=dict,
    deprecated=True,
    include_in_schema=False,
)
def post_receipt(
    receipt_id: str,
    payload: PostReceiptIn,
    request: Request,
    db: Session = Depends(get_db),
):
    """
    DEPRECATED: Usa POST /receipts/{id}/checkout en su lugar.
    Procesa un recibo y descuenta stock.
    """
    ensure_guc_from_request(request, db, persist=True)
    receipt_uuid = _validate_uuid(receipt_id, "Receipt ID")

    try:
        # Validar estado
        rec = db.execute(
            text("SELECT shift_id, status FROM pos_receipts WHERE id = :id::uuid"),
            {"id": str(receipt_uuid)},
        ).first()

        if not rec or rec[1] != "draft":
            raise HTTPException(status_code=400, detail="El recibo no está en borrador")

        shift_id = rec[0]

        # Obtener warehouse (UUID)
        wh_id = payload.warehouse_id
        if wh_id is None:
            row = db.execute(
                text(
                    "SELECT r.default_warehouse_id "
                    "FROM pos_shifts s "
                    "JOIN pos_registers r ON r.id = s.register_id "
                    "WHERE s.id = :sid"
                ),
                {"sid": str(shift_id)},
            ).first()
            wh_id = str(row[0]) if row and row[0] is not None else None

        if wh_id is None:
            raise HTTPException(
                status_code=400, detail="Se requiere especificar un almacén"
            )

        # Calcular totales
        tot_row = db.execute(
            text(
                "SELECT "
                "COALESCE(SUM(qty * unit_price), 0) AS subtotal, "
                "COALESCE(SUM(COALESCE(tax, 0)), 0) AS tax "
                "FROM pos_items "
                "WHERE receipt_id = :rid::uuid"
            ),
            {"rid": str(receipt_uuid)},
        ).first()

        pay_row = db.execute(
            text(
                "SELECT COALESCE(SUM(amount), 0) "
                "FROM pos_payments "
                "WHERE receipt_id = :rid::uuid"
            ),
            {"rid": str(receipt_uuid)},
        ).first()

        subtotal = float(tot_row[0] or 0)
        tax = float(tot_row[1] or 0)
        total = subtotal + tax
        paid = float(pay_row[0] or 0)

        if paid + 1e-6 < total:
            raise HTTPException(status_code=400, detail="Pago insuficiente")

        # Consumir stock
        items = db.execute(
            text("SELECT product_id, qty FROM pos_items WHERE receipt_id = :rid::uuid"),
            {"rid": str(receipt_uuid)},
        ).fetchall()

        for it in items:
            db.execute(
                text(
                    "INSERT INTO stock_moves("
                    "product_id, warehouse_id, qty, kind, ref_type, ref_id"
                    ") VALUES (:pid::uuid, :wid::uuid, :q, 'issue', 'pos_receipt', :rid::uuid)"
                ),
                {
                    "pid": str(it[0]),
                    "wid": str(wh_id),
                    "q": float(it[1]),
                    "rid": str(receipt_uuid),
                },
            )

            # Actualizar stock_items
            row = db.execute(
                text(
                    "SELECT id, qty FROM stock_items "
                    "WHERE warehouse_id = :wid::uuid AND product_id = :pid::uuid FOR UPDATE"
                ),
                {"wid": str(wh_id), "pid": str(it[0])},
            ).first()

            if row is None:
                db.execute(
                    text(
                        "INSERT INTO stock_items(warehouse_id, product_id, qty) "
                        "VALUES (:wid::uuid, :pid::uuid, 0)"
                    ),
                    {"wid": str(wh_id), "pid": str(it[0])},
                )
                cur_qty = 0.0
            else:
                cur_qty = float(row[1] or 0)

            new_qty = cur_qty - float(it[1])

            db.execute(
                text(
                    "UPDATE stock_items SET qty = :q "
                    "WHERE warehouse_id = :wid::uuid AND product_id = :pid::uuid"
                ),
                {"q": new_qty, "wid": str(wh_id), "pid": str(it[0])},
            )

        # Actualizar recibo
        db.execute(
            text(
                "UPDATE pos_receipts SET status = 'posted', totals = :tot "
                "WHERE id = :rid::uuid"
            ),
            {
                "rid": str(receipt_uuid),
                "tot": Json({"subtotal": subtotal, "tax": tax, "total": total}),
            },
        )

        db.commit()

        # Intentar encolar webhook (best-effort)
        try:
            webhook_payload = {
                "id": str(receipt_uuid),
                "total": total,
                "shift_id": str(shift_id),
            }
            db.execute(
                text(
                    "INSERT INTO webhook_deliveries(event, payload, target_url, status) "
                    "SELECT 'pos.receipt.posted', :p, s.url, 'PENDING' "
                    "FROM webhook_subscriptions s "
                    "WHERE s.event = 'pos.receipt.posted' AND s.active"
                ),
                {"p": Json(webhook_payload)},
            )
            db.commit()

            # Intentar enviar con Celery
            try:
                from apps.backend.celery_app import celery_app

                rows = db.execute(
                    text(
                        "SELECT id::text FROM webhook_deliveries "
                        "WHERE event = 'pos.receipt.posted' "
                        "ORDER BY created_at DESC LIMIT 10"
                    )
                ).fetchall()
                for r in rows:
                    celery_app.send_task(
                        "apps.backend.app.modules.webhooks.tasks.deliver",
                        args=[str(r[0])],
                    )
            except Exception:
                pass
        except Exception:
            db.rollback()

        return {"id": str(receipt_uuid), "status": "posted", "total": total}

    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=500, detail=f"Error al procesar recibo: {str(e)}"
        )


# ============================================================================
# ENDPOINTS DE SALUD Y UTILIDADES
# ============================================================================


@router.get("/health", include_in_schema=False)
def health_check():
    """Endpoint de salud para verificar que el módulo POS está funcionando"""
    return {
        "status": "healthy",
        "module": "pos",
        "timestamp": datetime.utcnow().isoformat(),
    }

