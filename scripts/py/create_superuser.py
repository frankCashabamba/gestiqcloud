#!/usr/bin/env python3
"""
Create or update a global SuperUser (admin) for the Admin panel.

Usage (from repo root):
  python scripts/py/create_superuser.py \
    --username admin --email admin@local --password Admin.2025

Notes
- Idempotent: if a SuperUser exists (by email OR username), it updates password when provided.
- Reads the same DATABASE_URL env as the API. Ensure DB is up.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Optional


def main(argv: Optional[list[str]] = None) -> int:
    p = argparse.ArgumentParser()
    p.add_argument("--username", required=True)
    p.add_argument("--email", required=True)
    p.add_argument("--password", required=True)
    p.add_argument(
        "--superadmin",
        action="store_true",
        default=True,
        help="set superadmin/staff flags (default true)",
    )
    args = p.parse_args(argv)

    # Ensure import roots for monorepo (repo/, repo/apps, repo/apps/backend)
    try:
        here = Path(__file__).resolve()
        repo_root = here.parents[2]
        candidates = [repo_root, repo_root / "apps", repo_root / "apps" / "backend"]
        for p in map(str, candidates):
            if p not in sys.path:
                sys.path.insert(0, p)
    except Exception:
        pass

    # Import backend modules
    try:
        from app.config.database import session_scope
        from app.models.auth.useradmis import SuperUser
        from app.modules.identity.infrastructure.passwords import PasslibPasswordHasher
        from sqlalchemy import text
    except Exception as e:
        print(
            "ERROR: could not import backend modules (app.*). Make sure the repo layout is intact and dependencies are installed."
        )
        print(f"Import error: {e}")
        return 2

    hasher = PasslibPasswordHasher()

    username = args.username.strip()
    email = args.email.strip().lower()
    password = args.password

    with session_scope() as db:
        # Ensure admin table exists in dev environments that skipped the baseline
        try:
            db.execute(
                text(
                    """
                DO $$
                BEGIN
                  IF NOT EXISTS (
                    SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='auth_user'
                  ) THEN
                    CREATE TABLE public.auth_user (
                      id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                      username VARCHAR(150) NOT NULL UNIQUE,
                      email VARCHAR(254) NOT NULL UNIQUE,
                      password_hash VARCHAR(255) NOT NULL,
                      is_active BOOLEAN NOT NULL DEFAULT TRUE,
                      is_superadmin BOOLEAN NOT NULL DEFAULT FALSE,
                      is_staff BOOLEAN NOT NULL DEFAULT FALSE,
                      is_verified BOOLEAN NOT NULL DEFAULT FALSE,
                      failed_login_count INTEGER NOT NULL DEFAULT 0,
                      locked_until TIMESTAMPTZ NULL,
                      last_login_at TIMESTAMPTZ NULL,
                      last_password_change_at TIMESTAMPTZ NULL,
                      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
                    );
                    CREATE INDEX IF NOT EXISTS ix_auth_user_id ON public.auth_user (id);
                    CREATE UNIQUE INDEX IF NOT EXISTS ix_auth_user_username ON public.auth_user (username);
                    CREATE UNIQUE INDEX IF NOT EXISTS ix_auth_user_email ON public.auth_user (email);
                    ALTER TABLE public.auth_user DISABLE ROW LEVEL SECURITY;
                  END IF;
                END $$;
                """
                )
            )
            # some drivers require a commit to make DDL visible to subsequent SELECTs in same txn
            try:
                db.commit()
            except Exception:
                pass
        except Exception:
            # best-effort; continue (migration 132 also ensures this)
            pass

        # Ensure id column autoincrements (identity or sequence default)
        try:
            from sqlalchemy import text as _text

            # Check current default
            res = db.execute(
                _text(
                    """
                    SELECT column_default FROM information_schema.columns
                    WHERE table_schema='public' AND table_name='auth_user' AND column_name='id'
                    """
                )
            ).fetchone()
            col_default = res[0] if res else None
            if not col_default:
                ok = False
                # Try identity first
                try:
                    db.execute(
                        _text(
                            "ALTER TABLE public.auth_user ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY"
                        )
                    )
                    db.commit()
                    ok = True
                except Exception:
                    try:
                        db.rollback()
                    except Exception:
                        pass
                if not ok:
                    # Fallback to owned sequence default
                    try:
                        db.execute(
                            _text(
                                "CREATE SEQUENCE IF NOT EXISTS public.auth_user_id_seq OWNED BY public.auth_user.id"
                            )
                        )
                        db.execute(
                            _text(
                                "ALTER TABLE public.auth_user ALTER COLUMN id SET DEFAULT nextval('public.auth_user_id_seq')"
                            )
                        )
                        db.commit()
                    except Exception:
                        try:
                            db.rollback()
                        except Exception:
                            pass
        except Exception:
            # non-fatal; insertion will still try and reveal real issue
            pass
        existing = (
            db.query(SuperUser)
            .filter((SuperUser.email == email) | (SuperUser.username == username))
            .first()
        )
        if existing:
            changed = False
            # Update username/email if different and not taken by another user
            if existing.username != username:
                other = (
                    db.query(SuperUser)
                    .filter(SuperUser.username == username, SuperUser.id != existing.id)
                    .first()
                )
                if other:
                    print(
                        f"ERROR: username '{username}' already in use by id={other.id}"
                    )
                    return 3
                existing.username = username
                changed = True
            if existing.email != email:
                other_e = (
                    db.query(SuperUser)
                    .filter(SuperUser.email == email, SuperUser.id != existing.id)
                    .first()
                )
                if other_e:
                    print(f"ERROR: email '{email}' already in use by id={other_e.id}")
                    return 4
                existing.email = email
                changed = True
            if password:
                # Re-hash only if not matching (verify returns tuple)
                try:
                    ok, new_hash = hasher.verify(password, existing.password_hash)
                except Exception:
                    ok, new_hash = False, hasher.hash(password)
                if not ok or new_hash:
                    existing.password_hash = new_hash or hasher.hash(password)
                    changed = True
            if args.superadmin:
                # ensure flags
                if not existing.is_superadmin:
                    existing.is_superadmin = True
                    changed = True
                if not existing.is_staff:
                    existing.is_staff = True
                    changed = True
                if not existing.is_active:
                    existing.is_active = True
                    changed = True
                if getattr(existing, "is_verified", None) is not True:
                    try:
                        existing.is_verified = True  # type: ignore[attr-defined]
                        changed = True
                    except Exception:
                        pass
            if changed:
                db.add(existing)
            print(
                f"OK Existing SuperUser: id={existing.id} username={existing.username} email={existing.email}"
            )
            return 0

        # Create new SuperUser
        su = SuperUser(
            username=username,
            email=email,
            password_hash=hasher.hash(password),
            is_active=True,
            is_superadmin=True if args.superadmin else False,
            is_staff=True if args.superadmin else False,
        )
        # optional field in model: is_verified
        try:
            su.is_verified = True  # type: ignore[attr-defined]
        except Exception:
            pass
        db.add(su)
        db.flush()
        print(
            f"OK Created SuperUser: id={su.id} username={su.username} email={su.email}"
        )
        return 0


if __name__ == "__main__":
    raise SystemExit(main())
